# Задание 1

Необходимо спроектировать две модели сервиса доставки еды:
- модель по Кимбаллу;
- модель Data Vault (DV).


# Задание 2

## Пункт 1 (agg)

Посчитать число слов начинающихся с одинаковых префиксов из `PREFIX_LEN` букв. Слова короче `PREFIX_LEN` - игнорировать - качестве примера взять PREFIX_LEN=3 - Задать в качестве константы в коде меппера и/или редьюсера. Символы и цифры считать разделителями. Формат вывода - `f"{prefix}-{count}"`.

## Пункт 2 (join)

Написать inner-join на MapReduce (ReduceSideJoin) для двух таблиц по полю product_id. Таблицы:
1. shop_product.csv содержит поля product_id и description
2. shop_price.csv содержит поля product_id и price
В результате должен получится файл из трех колонок: (product_id, description, price), разделитель – \t, порядок строк не важен.


# Задание 3

- Создать внешнюю таблицу на данных coreDemography.
- Написать запрос рассчитывающий распределение дней рождения по месяцам. В результате должна получится таблица из двух колонок (month, cnt)


# Задание 4

## Пункт 1 (Spark)

Необходимо собрать статистику для товаров из products_for_stat.csv (и только для товаров из этого файла!).
Для предложенных товаров необходимо вычислить минимальную, максимальную и среднюю цену по всем городам (будет получен датасет price_stat), результат сохранить в hdfs. Далее, из набора данных ОК следует для всех пользователей из городов, цена на товары в которых выше средней, собрать статистику, которая будет содержать: название города, число пользователей из этого города, средний возраст пользователей, число пользователей мужчин, число пользователей женщин, доля мужчин, доля женщин (датасет ok_dem). Из полученного датасета нужно будет выбрать города с максимальным и минимальным средним возрастом, максимальной долей мужчин и максимальной долей женщин. Для этих городов в данных Росстат нужно будет выбрать самый дешевый и самый дорогой товары, разницу в цене между ними (датасет product_stat)

Итого в hdfs должны получить 3 директории с результатами шагов: price_stat, ok_dem, product_stat, со следующими полями:
price_stat
- product_id
- min_price
- max_price
- price_avg

ok_dem - cохранить результат нужно в один файл с сортировкой по убыванию user_cnt.
- city_name
- user_cnt
- age_avg
- men_cnt
- women_cnt
- men_share
- women_share

product_stat
- city_name
- cheapest_product_name
- most_expensive_product_name
- price_difference

## Пункт 2 (Luigi)

Во второй части необходимо реализованные шаги в первой части объединить в единый пайплайн используя фреймворк Luigi
